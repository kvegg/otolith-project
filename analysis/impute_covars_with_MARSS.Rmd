---
title: "Imputation of missing covariates"
output:
  html_document:
    keep_md: yes
    theme: cerulean
    toc: true
    toc_float: true
    toc_depth: 3
    fig_caption: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

<br/>

[__Mark Scheuerell__](https://faculty.washington.edu/scheuerl/)  
_Fish Ecology Division, Northwest Fisheries Science Center, National Marine Fisheries Service, National Oceanic and Atmospheric Administration, Seattle, WA, USA_

__Karl Veggerby__  
_Ocean Associates, Seattle, WA, USA_

***

This is version `r paste0('0.',format(Sys.time(), '%y.%m.%d'))`.

***

# Background

We would like to examine temperature as a possible covariate in the analyses of the growth data. However, the temperature are not complete for all sites and times, and therefore we have to impute some of the values based upon measurements from two different sources: Team Carcass and Team Tagging. To do so, we will use the __MARSS__ package, which is designed to fit autoregressive models to multivariate time series data.

Specifically, we have data from $n$ = 7 streams and 1-2 sources for each stream. For temperature measured at site $i$ from source $j$ on day $d$ ($T_{i,j,d}$), we can write

\begin{equation} \label{eq1}
  \begin{gathered}
    \mathbf{T}_{d} = \mathbf{Z} \mathbf{x}_{d} + \mathbf{a} + \mathbf{v}_{d} \\
    \mathbf{x}_{d} = \mathbf{B} \mathbf{x}_{d-1} + \mathbf{C} \mathbf{c}_{d-h} + \mathbf{w}_{d},
  \end{gathered}
\end{equation}

where $\mathbf{T}_{d}$ is an $n \times 1$ vector of the $T_{i,j,d}$ and $\mathbf{x}_{d}$ is an $m \times 1$ vector of the true, but unobserved temperature in each stream on day $d$. Here, $m < n$ because we have 2 sources of data from some streams. The vectors of observation ($\mathbf{v}_{d}$) and process ($\mathbf{w}_{d}$) errors are both distributed as multivariate normal with means $\mathbf{0}$ and covariance matrices $\mathbf{R}$ and $\mathbf{Q}$, respectively.

The specific forms for $\mathbf{Z}$ , $\mathbf{a}$ and $\mathbf{B}$ will be chosen initially based on visually identified shared/different characteristics among the different sites. The values in the matrix $\mathbf{C}$ determine the effect(s) of any potential, and possibly lagged, covariates contained in $\mathbf{c}_{d-h}$. Those will also be chosen after inspection of the data from the different sources


# Requirements

```{r load_pkgs, message=FALSE}
## for analysis
library(MARSS)
## for plotting
library(viridisLite)
## for dir mgmt
library(here)
datadir <- here("data")
```

# Data munging

We begin by loading the data file with the temperature summaries by time (rows) and location (cols).

```{r load_covars}
## load obs covariates
cobs <- read.csv(file.path(datadir, "daily_mean_temp.csv"),
                 stringsAsFactors = FALSE)
## inspect data
head(cobs)
```

Let's simplify some names in the file and round the observations to the nearest 0.01.

```{r change_colnames}
## simplify colnames
colnames(cobs) <- gsub("data_source", replacement = "s", x = colnames(cobs))
colnames(cobs) <- gsub("daily_mean", replacement = "T", x = colnames(cobs))
## site abbrevs
sites <- sort(gsub("T_", replacement = "", x = colnames(cobs)[10:16]))
## simplify sources
cobs[cobs=="team carcass"] <- "car"
cobs[cobs=="achord_gordy"] <- "tag"
## round temps
cobs[,grep("T_", colnames(cobs))] <- round(cobs[,grep("T_", colnames(cobs))], 2)
```

The temperature data come from two different sources:

  1. the food web group (Sanderson et al.), and  
  2. the juvenile tagging group (Achord, Axel et al.).  
  
We need to split the data out by those groups.

```{r split_obs_grps}
## empty data frames
car <- tag <- matrix(NA, nrow(cobs), length(sites),
                     dimnames = list(NULL, sites))
## measurements
vals <- cobs[,-(1:9)]
## indices of data type
i_car <- cobs[,3:9] == "car"
i_tag <- cobs[,3:9] == "tag"
## group-specific data
car[i_car] <- vals[i_car]
tag[i_tag] <- vals[i_tag]
## drop any sites with all NA's
car <- car[,apply(car, 2, function(x) !all(is.na(x)))]
colnames(car) <- paste0(colnames(car), "_car")
tag <- tag[,apply(tag, 2, function(x) !all(is.na(x)))]
colnames(tag) <- paste0(colnames(tag), "_tag")
## regroup by sites & source
cobs_m <- cbind(car, tag)
cobs_m <- cobs_m[,sort(colnames(cobs_m))]
## remove tailing rows with all NA
all_na <- apply(apply(cobs_m, 1, is.na), 2, all)
cobs_m <- cobs_m[!all_na,]
```

# Plot the data

## All sites together

```{r data_plot, fig.align="center"}
par(mai=c(0.9,0.9,0.1,0.1), omi=c(0,0,0,0))
## plot the data
matplot(cobs_m, type = "l", lty = "solid",
        lwd = 2, las = 1,
        ylab = "Temperature (C)", xaxt="n",
        col = plasma(ncol(cobs_m), alpha = 0.5, begin = 0, end = 1))
years <- unique(cobs$year)
n_yrs <- length(years)
n_days <- nrow(cobs) / n_yrs
axis(side = 1,
     at = seq(n_days / 2, by = n_days, length.out = n_yrs),
     labels = years,
     tick = FALSE, line = -1,
     cex.axis = 0.7)
```

## By site

```{r plot_by_site, fig.height=10, fig.width=7, fig.align="center"}
par(mfrow = c(length(sites), 1),
    mai = c(0.3,0.5,0.2,0.1),
    omi = c(0,0,0,0))
for(i in sites) {
  ## site-specific data
  tmp <- cobs_m[, grep(i, colnames(cobs_m)), drop = FALSE]
  ## plot the data
  matplot(tmp, type = "l", lty = "solid",
          lwd = 2, las = 1,
          ylab = "Temperature (C)", xaxt="n", main = i,
          col = plasma(ncol(tmp), alpha = 1, begin = 0.1, end = 0.3))
  axis(side = 1,
       at = seq(n_days / 2, by = n_days, length.out = n_yrs),
       labels = years,
       tick = FALSE, line = -1)
}
```

# Imputation

Based on the plots above, we will use the following forms for the vectors and matrices in Eqn \ref{eq1} that relate the states to themselves and the observations to the states. Specifically, it looks as though the seasonal patterns dominate in each stream, with very little evidence for an increasing or decreasing trend. Furthermore, other than subtle changes in the overall level (mean), the streams appear to move up and down in synchrony. Thus, we will set

* $\mathbf{Z}$ equal to an $n \times 1$ column vector of 1's ($[1~1\dots1]^{\top}$), such that all of the data are assumed to be observations of a single overall temperature regime;

* $\mathbf{a}$ equal to an $n \times 1$ column vector where the elements are shared for data from the same stream (_e.g._, both sets of data for Elk would get the same level, but Elk is different from Valley);

* $\mathbf{v}_d \sim \text{MVN}(\mathbf{0}, \mathbf{R})$ with $\mathbf{R}$ equal to an $n \times n$ matrix with the same variance ($r$) in each element of the diagonal and 0's elsewhere,

$$
\mathbf{R} = 
  \begin{bmatrix}
  r & 0 & \dots & 0 \\
  0 & r & \dots & 0 \\
  \vdots & \vdots & \ddots & \vdots \\
  0 & 0 & \dots & r \\
  \end{bmatrix};
$$

* $\mathbf{B}$ equal to an $m \times m$ matrix with different parameters down the diagonal and 0's elsewhere, which will allow the true temperature in each stream to follow a first-order autoregressive process,

$$
\mathbf{B} = 
  \begin{bmatrix}
  b_1 & 0 & \dots & 0 \\
  0 & b_2 & \dots & 0 \\
  \vdots & \vdots & \ddots & \vdots \\
  0 & 0 & \dots & b_m \\
  \end{bmatrix};
$$

* $\mathbf{C}$ equal to an $m \times 1$ vector with unique parameters to allow for varying effects of the seasonal signal on each stream ($[C_1 ~ C_2 \dots C_m]^{\top}$);

* $\mathbf{c}$ equal to a discrete sine wave with a period of 365 days, such that $\mathbf{c}_t$ is a scalar; and

* $\mathbf{w}_d \sim \text{MVN}(\mathbf{0}, \mathbf{Q})$ with $\mathbf{Q}$ equal to an $m \times m$ matrix with the same variance ($q$) in each element of the diagonal and the same covariance ($p$) elsewhere,

$$
\mathbf{Q} = 
  \begin{bmatrix}
  q & p & \dots & p \\
  p & q & \dots & p \\
  \vdots & \vdots & \ddots & \vdots \\
  p & p & \dots & q \\
  \end{bmatrix}.
$$


